// update anilist scores for all tiered entries
// requires that the entries have been scored by scoreSortedCrabs()
function updateAllScores() {
  if (user.token == null) {
    alert("no token found, please login to anilist");
    return;
  }

  if (user.scoredEntries.length == 0) return; // empty tier list

  var curScore;
  var idArray = [];
  curScore = user.scoredEntries[0].assignedScore;
  for (const entry of user.scoredEntries) {
    if (curScore != entry.assignedScore) {
      // new score, process previous entries
      updateScores(user.token, idArray, curScore);
      curScore = entry.assignedScore;
      idArray = [];
    }
    if (entry.assignedScore === entry.mediaListEntry.score) continue; // no change to existing score
    idArray.push(entry.mediaListEntry.id);
  }
  updateScores(user.token, idArray, curScore); // handle final batch
}

// set anilist scores to 0 for any entry that wasn't in the tier list
function resetUntieredEntryScores() {
  if (user.token == null) {
    alert("no token found, please login to anilist");
    return;
  }

  var idArray = [];
  for (const entry of user.list) {
    if (entry.assignedScore == null) {
      idArray.push(entry.mediaListEntry.id);
    }
  }
  updateScores(user.token, idArray, 0);
}

// assign scores to the sorted entries
function scoreSortedCrabs(scoringMethod = "unorderedWithinTier") {
  user.scoredEntries = [];

  // get arrays of anime from the sorted elements
  const rows = document.getElementsByClassName("tier-row");
  for (const row of rows) {
    // get relevant information and entries from row
    var children = row.querySelector(".tier-sort").children;
    var [lo, hi] = [parseInt(row.dataset.lo), parseInt(row.dataset.hi)];
    var score = hi;

    for (const child of children) {
      // iterate through entries in row entry in list and assign score
      const index = parseInt(child.id);
      const entry = user.list[index];
      entry.assignedScore = score;
      user.scoredEntries.push(entry);
      if (scoringMethod === "orderedWithinTier") {
        score -= (hi - lo) / row.children.length;
      }
    }
  }
}

// get list of entries with a difference (between lo and hi) between the user's given score and the tier list assigned score
function findDifferenceBetween(lo, hi) {
  const array = [];
  for (const entry of user.scoredEntries) {
    const diff =
      entry.mediaListEntry.score != null
        ? entry.assignedScore - entry.mediaListEntry.score
        : 0;
    if (Math.abs(diff) >= lo && Math.abs(diff) <= hi) {
      array.push({ entry, diff });
    }
  }
  return array;
}

// if the entry has a score already on anilist, remove it from consideration
function hideScoredEntries() {
  const crabs = document.getElementsByClassName("crab");
  for (const crab of crabs) {
    const index = parseInt(crab.id);
    if (user.list[index].mediaListEntry.score != 0) {
      crab.style.display = "none";
    }
  }
}

export {};
